# OpenCode Manager Redesign Plan

**Date:** 2026-02-10
**Status:** Planning Phase
**Goal:** Align OpenCode Manager with OpenCode's native architecture for maximum effectiveness

---

## Table of Contents

1. [Current Architecture Problems](#current-architecture-problems)
2. [Target Architecture](#target-architecture)
3. [Key Decisions](#key-decisions)
4. [Implementation Phases](#implementation-phases)
5. [Migration Strategy](#migration-strategy)
6. [API Changes](#api-changes)

---

## Current Architecture Problems

### What We Built (Fighting OpenCode)
```
User → MoJoAssistant MCP (port 8000)
         ↓
     OpenCode Manager (Python)
         ↓
     Multiple OpenCode Instances (separate processes)
         ├─ Port 4100: Manual clone → ~/.memory/opencode-sandboxes/Mobile_MoJoAssistant_Dev/repo
         ├─ Port 4104: Manual clone → ~/.memory/opencode-sandboxes/personal-update-version-of-chatmcp-client/repo
         └─ Port 4XXX: Manual clone → ~/.memory/opencode-sandboxes/{project-name}/repo
```

### Problems Discovered

1. **Duplicate Projects**
   - Same git repo cloned multiple times = same projectID
   - Sessions leak across clones (confusing UX)
   - Example: Port 4100 shows sessions from both `/home/alex/Development/Personal/MoJoAssistant` and `~/.memory/opencode-sandboxes/Mobile_MoJoAssistant_Dev/repo`

2. **Not Using Native Features**
   - OpenCode has `/experimental/worktree` for sandboxes
   - We're manually cloning repos instead
   - Missing: worktree lifecycle management, native git worktree benefits

3. **Inefficient Resource Usage**
   - Multiple OpenCode processes for the same repo
   - Each process loads same project data
   - Separate ports, passwords, config per "project"

4. **Conceptual Mismatch**
   - We treat `project_name` as primary key
   - OpenCode treats `git_url` as primary key
   - Our "projects" are actually "workspaces" in OpenCode terms

---

## Target Architecture

### Aligned with OpenCode Design
```
User → MoJoAssistant MCP Server (port 8000)
         ↓
     OpenCode Manager (Python)
       - Project Registry: git_url → { port, project_id, base_dir, worktrees[] }
       - One OpenCode instance per unique git repo
         ↓
     OpenCode Instance #1 (e.g., port 4100)
       - Git Repo: git@github.com:user/repo-A.git
       - Base Dir: /home/user/Development/repo-A (or ~/.opencode-projects/repo-A)
       ├─ Main worktree (primary branch)
       ├─ Sandbox: feature-test (worktree on branch feature-test)
       ├─ Sandbox: experiment (worktree on branch experiment)
       └─ Sessions (project-wide, visible in all worktrees)
         ↓
     OpenCode Instance #2 (e.g., port 4104)
       - Git Repo: git@github.com:user/repo-B.git
       - Base Dir: ~/.opencode-projects/repo-B
       ├─ Main worktree
       └─ Sessions
```

### Key Principles

1. **One OpenCode Instance Per Git Repository**
   - Primary key: `git_url` (normalized)
   - Project ID: Generated by OpenCode from git remote

2. **Use Native Worktree API**
   - `POST /experimental/worktree` to create sandboxes
   - OpenCode handles `git worktree add`, branch creation
   - No more manual cloning

3. **Accept Session Sharing**
   - Sessions belong to projects, not worktrees
   - This is **by design** for collaboration
   - Users can work on feature in sandbox, switch to main, same history

4. **Per-Instance Configuration**
   - Each OpenCode instance can have different model (via PATCH /config)
   - SSH key per git repo (for deploy key)
   - One password per instance

---

## Key Decisions

### Decision 1: Where to Clone Repositories Initially?

**Options:**
- **A. User-specified directory** (flexible, user controls location)
- **B. Managed directory** `~/.opencode-projects/{sanitized-repo-name}` (opinionated, clean)
- **C. Hybrid:** Default to managed, allow override

**Recommendation:** **Option C (Hybrid)**
- Default: `~/.opencode-projects/{owner}-{repo}`
- Allow: User can specify custom base directory
- Benefits: Clean defaults, flexibility when needed

**API:**
```python
opencode_project_start(
    git_url="git@github.com:user/repo.git",
    base_dir=None  # Optional override
)
# Returns: { project_id, port, base_dir }
```

### Decision 2: How to Handle Multiple Clones of Same Repo?

**Scenario:** User wants to work on repo from two locations (e.g., main dev + sandbox clone)

**Options:**
- **A. Not supported** - Use worktrees instead
- **B. Suffix naming:** `git_url#instance-name` to create separate "projects"
- **C. Multiple OpenCode instances:** One per clone (current approach)

**Recommendation:** **Option A (Use Worktrees)**
- Rationale: Align with OpenCode design, educate users
- If user really needs separate clones: they can use different remotes (fork)
- Worktrees are more efficient (shared .git)

**Migration Path:**
- Detect existing clones of same repo
- Warn user, suggest converting to worktrees
- Provide `opencode_migrate_to_worktree()` tool

### Decision 3: SSH Key Management

**Options:**
- **A. One key per git_url** (simpler)
- **B. One key per OpenCode instance** (current approach)
- **C. User's global SSH key** (reuse ~/.ssh/id_ed25519)

**Recommendation:** **Option A (One key per git_url)**
- Key location: `~/.memory/opencode-keys/{sanitized-git-url}-deploy`
- Exposed via MCP tool: `opencode_get_deploy_key(git_url)`
- User adds to GitHub repo deploy keys
- Shared across all worktrees of that repo

### Decision 4: Session Visibility

**Current Reality:** Sessions are project-scoped, visible from any worktree.

**Options:**
- **A. Accept it** - Sessions are global per project
- **B. Filter by worktree** - Add UI filtering (sessions still global in storage)
- **C. Request OpenCode feature** - Worktree-scoped sessions (unlikely to be added)

**Recommendation:** **Option B (Filter by worktree)**
- Accept global session storage (OpenCode design)
- Add `worktree` filter in MCP tool list operations
- Document behavior clearly for users

---

## Implementation Phases

### Phase 1: Refactor Core Data Model (Week 1)

**Goal:** Change project identity from `project_name` to `git_url`

**Tasks:**
1. Update `models.py`:
   ```python
   @dataclass
   class ProjectConfig:
       git_url: str              # Primary key (was: project_name)
       project_id: str           # OpenCode's hash
       base_dir: Path            # Where repo is cloned
       worktrees: List[str]      # List of worktree names
       ssh_key_path: str
       opencode_password: str
       opencode_port: int
       # ... other fields
   ```

2. Update `state_manager.py`:
   - Change state file key: `git_url` instead of `project_name`
   - Add migration for existing state

3. Update `config_manager.py`:
   - MCP server registry: key by `git_url`
   - Generate `project_name` from git_url for display

4. Update `manager.py`:
   - `start_project(git_url, base_dir=None)` → returns `{ project_id, port, base_dir }`
   - `stop_project(git_url)`
   - `get_project(git_url)`

**Deliverables:**
- [ ] Updated data models
- [ ] Migration script for existing state
- [ ] Unit tests for new models

### Phase 2: Add Worktree Support (Week 2)

**Goal:** Wrap OpenCode's `/experimental/worktree` API

**Tasks:**
1. Create `worktree_manager.py`:
   ```python
   class WorktreeManager:
       def create_worktree(self, git_url: str, name: str, branch: str = None, start_command: str = None)
       def list_worktrees(self, git_url: str)
       def delete_worktree(self, git_url: str, name: str)
       def reset_worktree(self, git_url: str, name: str)
   ```

2. Integrate with `process_manager.py`:
   - HTTP client for OpenCode API calls
   - Error handling, retries

3. Add to `manager.py`:
   - `create_sandbox(git_url, name, **kwargs)`
   - `list_sandboxes(git_url)`
   - `delete_sandbox(git_url, name)`

**Deliverables:**
- [ ] WorktreeManager implementation
- [ ] Integration tests with live OpenCode instance
- [ ] API documentation

### Phase 3: Update MCP Tools (Week 3)

**Goal:** Expose new architecture via MCP protocol

**Old Tools (Remove):**
```python
opencode_start(project_name, git_url)
opencode_stop(project_name)
opencode_status(project_name)
```

**New Tools:**
```python
# Project Lifecycle
opencode_project_start(git_url, base_dir=None, model=None)
  → { project_id, port, base_dir, message }

opencode_project_list()
  → [{ git_url, project_id, port, base_dir, status, worktrees }]

opencode_project_stop(git_url)
  → { status, message }

opencode_project_restart(git_url)
  → { status, port, message }

# Sandbox/Worktree Management
opencode_sandbox_create(git_url, name, branch=None, start_command=None)
  → { name, path, branch }

opencode_sandbox_list(git_url)
  → [{ name, path, branch }]

opencode_sandbox_delete(git_url, name)
  → { status, message }

# Session Operations (unchanged, just add git_url parameter)
opencode_session_create(git_url, parent_id=None, worktree=None)
opencode_session_list(git_url, worktree=None)  # Optional filter
opencode_session_message(git_url, session_id, message)
# ... etc

# Configuration
opencode_llm_config()  # Global config
opencode_llm_set_model(git_url, model)  # Per-instance
opencode_get_deploy_key(git_url)  # Get public SSH key
```

**Implementation:**
1. Update `app/mcp/core/tools.py`:
   - Remove old tool definitions
   - Add new tool schemas
   - Update execution methods

2. Update routing in `execute()` method

3. Add proper error handling and validation

**Deliverables:**
- [ ] Updated tool definitions
- [ ] Updated `tools.py` execution methods
- [ ] Integration tests via MCP protocol
- [ ] Updated user documentation

### Phase 4: SSH Key & Deploy Key Management (Week 3)

**Goal:** Simplify SSH key workflow for users

**Tasks:**
1. Update `ssh_manager.py`:
   ```python
   def generate_key_for_repo(self, git_url: str) -> Tuple[str, str, str]:
       # Key location: ~/.memory/opencode-keys/{sanitized-git-url}-deploy
       # Returns: (private_key_path, public_key_path, public_key_content)
   ```

2. Add `get_deploy_key()` to `manager.py`:
   ```python
   async def get_deploy_key(self, git_url: str) -> Dict[str, Any]:
       # Returns public key + instructions for GitHub
   ```

3. Add MCP tool `opencode_get_deploy_key(git_url)`:
   - Returns public key
   - Provides GitHub URL for deploy key setup
   - Instructions for adding key

**User Workflow:**
```
1. User: "Start working on git@github.com:user/repo.git"
2. MCP Tool: opencode_project_start(git_url)
   → Generates SSH key if doesn't exist
   → Returns: "SSH key generated. Run opencode_get_deploy_key() to add it to GitHub"
3. User: "Get deploy key"
4. MCP Tool: opencode_get_deploy_key(git_url)
   → Returns: public key + GitHub URL
5. User: Adds key to GitHub (manual step)
6. OpenCode: Can now clone/pull/push
```

**Deliverables:**
- [ ] SSH key generation per git_url
- [ ] MCP tool for deploy key retrieval
- [ ] User documentation with screenshots

### Phase 5: Migration & Testing (Week 4)

**Goal:** Migrate existing projects, comprehensive testing

**Tasks:**
1. Create migration script:
   ```python
   def migrate_v1_to_v2():
       # Read old state file
       # For each project:
       #   - Map project_name → git_url
       #   - Detect if same git_url has multiple clones
       #   - Warn about session visibility
       #   - Update state file format
   ```

2. Handle edge cases:
   - Multiple clones of same repo → suggest worktrees
   - Missing git remotes → keep as-is, warn
   - Port conflicts → reassign ports

3. Testing:
   - Unit tests for all new managers
   - Integration tests: start → create sandbox → session → message
   - Load testing: multiple projects, many worktrees
   - Error handling: network failures, auth failures

4. Documentation:
   - Update README
   - Add architecture diagram
   - User guide: common workflows
   - Troubleshooting guide

**Deliverables:**
- [ ] Migration script with dry-run mode
- [ ] Comprehensive test suite
- [ ] Updated documentation
- [ ] Release notes

---

## Migration Strategy

### For Existing Users

**Step 1: Backup**
```bash
cp -r ~/.memory/opencode-state.json ~/.memory/opencode-state.json.backup
cp -r ~/.memory/opencode-mcp-tool-servers.json ~/.memory/opencode-mcp-tool-servers.json.backup
```

**Step 2: Dry Run Migration**
```bash
python3 -m app.mcp.opencode.migrate --dry-run
# Shows what will change, warns about duplicates
```

**Step 3: Run Migration**
```bash
python3 -m app.mcp.opencode.migrate --execute
```

**Step 4: Restart OpenCode Manager**
```bash
# Old projects will be stopped
# User can restart with new API: opencode_project_start(git_url)
```

### Handling Duplicate Projects

**Scenario:** User has:
- Port 4100: `~/.memory/opencode-sandboxes/Mobile_MoJoAssistant_Dev/repo` (git@github.com:user/repo.git)
- Port 4104: `/home/user/Development/Personal/MoJoAssistant` (git@github.com:user/repo.git)

**Migration:**
1. Detect same git_url
2. Keep one instance (prefer main dev directory)
3. Convert other to worktree (if possible)
4. Or: Stop duplicate, warn user

**User Experience:**
```
⚠️  Warning: Found 2 OpenCode instances for git@github.com:AvengerMoJo/MoJoAssistant.git:
  - Port 4100: ~/.memory/opencode-sandboxes/Mobile_MoJoAssistant_Dev/repo
  - Port 4104: /home/alex/Development/Personal/MoJoAssistant

Recommended: Keep port 4104 (main dev directory), convert port 4100 to worktree.

Actions:
  1. Stop port 4100
  2. Create worktree: opencode_sandbox_create(git_url, "mobile-dev")
  3. Sessions from both will be visible (by design)

Proceed? (y/N)
```

---

## API Changes

### Breaking Changes

#### MCP Tool Signatures (Before → After)

```python
# OLD
opencode_start(project_name: str, git_url: str, user_ssh_key: str = None)

# NEW
opencode_project_start(git_url: str, base_dir: str = None, model: str = None)
```

```python
# OLD
opencode_status(project_name: str)

# NEW
opencode_project_list()  # Get all projects
# Or for specific project:
# Find by git_url in the list
```

```python
# OLD
opencode_session_create(project_name: str, parent_id: str = None)

# NEW
opencode_session_create(git_url: str, parent_id: str = None, worktree: str = None)
```

### New MCP Tools

```python
# Sandbox management
opencode_sandbox_create(git_url, name, branch=None, start_command=None)
opencode_sandbox_list(git_url)
opencode_sandbox_delete(git_url, name)

# Deploy key management
opencode_get_deploy_key(git_url)

# Per-instance config
opencode_llm_set_model(git_url, model)
```

### Removed MCP Tools

```python
# These become part of opencode_project_list():
opencode_status(project_name)
opencode_restart_project(project_name)  # Use opencode_project_restart(git_url)

# These file operations were removed (redundant):
opencode_find_files(...)
opencode_search_content(...)
opencode_file_content(...)
opencode_config_get(...)
opencode_list_providers(...)
```

---

## Success Metrics

1. **Alignment with OpenCode**
   - [ ] One OpenCode instance per git repo
   - [ ] Using native worktree API
   - [ ] No manual clones

2. **Resource Efficiency**
   - [ ] Fewer OpenCode processes (consolidate duplicates)
   - [ ] Faster startup (reuse existing instances)
   - [ ] Lower memory usage

3. **User Experience**
   - [ ] Clear project identity (git_url, not arbitrary name)
   - [ ] Easy sandbox creation (one MCP tool call)
   - [ ] Simplified SSH key setup (get_deploy_key tool)

4. **Code Quality**
   - [ ] Test coverage >80%
   - [ ] All edge cases documented
   - [ ] Migration script tested on real projects

---

## Timeline

- **Week 1:** Phase 1 (Data model refactor)
- **Week 2:** Phase 2 (Worktree support)
- **Week 3:** Phase 3 & 4 (MCP tools + SSH keys)
- **Week 4:** Phase 5 (Migration + testing)
- **Total:** 4 weeks

---

## Open Questions

1. **Should we support multiple base directories for same repo?**
   - E.g., user has repo cloned in two places
   - Current answer: No, use worktrees. But revisit if strong user need.

2. **How to handle repos without remotes?**
   - Local-only repos (no git remote)
   - Current answer: Use local path as "git_url", warn that sessions won't be portable

3. **Should we auto-migrate on startup?**
   - Or require explicit migration command?
   - Current answer: Explicit migration, too risky to auto-migrate

4. **Global MCP tool architecture?**
   - Current: One opencode-mcp-tool routing to N OpenCode servers
   - Keep or change?
   - Current answer: Keep, it's working. Focus on manager redesign.

---

## Next Steps

1. Review this plan with team/user
2. Get approval on key decisions
3. Create GitHub issues for each phase
4. Start Phase 1 implementation

**Status:** Awaiting approval to proceed with Phase 1.
